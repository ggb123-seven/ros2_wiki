#!/usr/bin/env python3
"""
Claude Code ç›‘è§†å™¨
ç›‘è§†é¡¹ç›®æ–‡ä»¶å˜æ›´ã€åº”ç”¨çŠ¶æ€ã€é”™è¯¯æ—¥å¿—ç­‰
"""

import os
import time
import json
import hashlib
from datetime import datetime
from pathlib import Path

class ClaudeCodeMonitor:
    def __init__(self, project_path="."):
        self.project_path = Path(project_path)
        self.file_hashes = {}
        self.log_file = "claude_monitor.log"
        self.status_file = "claude_status.json"
        
    def calculate_file_hash(self, file_path):
        """è®¡ç®—æ–‡ä»¶MD5å“ˆå¸Œå€¼"""
        try:
            with open(file_path, 'rb') as f:
                return hashlib.md5(f.read()).hexdigest()
        except Exception as e:
            return None
    
    def scan_files(self):
        """æ‰«æé¡¹ç›®æ–‡ä»¶"""
        important_files = [
            "*.py", "*.js", "*.html", "*.css", "*.md", 
            "*.yaml", "*.yml", "*.json", "*.txt"
        ]
        
        current_files = {}
        for pattern in important_files:
            for file_path in self.project_path.rglob(pattern):
                if not any(part.startswith('.') for part in file_path.parts):
                    rel_path = file_path.relative_to(self.project_path)
                    current_files[str(rel_path)] = self.calculate_file_hash(file_path)
        
        return current_files
    
    def detect_changes(self):
        """æ£€æµ‹æ–‡ä»¶å˜æ›´"""
        current_files = self.scan_files()
        changes = {
            'modified': [],
            'added': [],
            'deleted': []
        }
        
        # æ£€æµ‹ä¿®æ”¹å’Œæ–°å¢
        for file_path, file_hash in current_files.items():
            if file_path in self.file_hashes:
                if self.file_hashes[file_path] != file_hash:
                    changes['modified'].append(file_path)
            else:
                changes['added'].append(file_path)
        
        # æ£€æµ‹åˆ é™¤
        for file_path in self.file_hashes:
            if file_path not in current_files:
                changes['deleted'].append(file_path)
        
        self.file_hashes = current_files
        return changes
    
    def log_event(self, event_type, message, details=None):
        """è®°å½•äº‹ä»¶æ—¥å¿—"""
        timestamp = datetime.now().isoformat()
        log_entry = {
            'timestamp': timestamp,
            'type': event_type,
            'message': message,
            'details': details or {}
        }
        
        # å†™å…¥æ—¥å¿—æ–‡ä»¶
        with open(self.log_file, 'a', encoding='utf-8') as f:
            f.write(f"{timestamp} [{event_type}] {message}\n")
            if details:
                f.write(f"  è¯¦æƒ…: {json.dumps(details, ensure_ascii=False, indent=2)}\n")
        
        # è¾“å‡ºåˆ°æ§åˆ¶å°
        print(f"ğŸ” [{event_type}] {message}")
        if details:
            print(f"   è¯¦æƒ…: {details}")
    
    def check_application_status(self):
        """æ£€æŸ¥åº”ç”¨çŠ¶æ€"""
        status = {
            'timestamp': datetime.now().isoformat(),
            'files_monitored': len(self.file_hashes),
            'wsgi_exists': os.path.exists('wsgi.py'),
            'app_exists': os.path.exists('app.py'),
            'requirements_exists': os.path.exists('requirements.txt'),
            'render_config_exists': os.path.exists('render.yaml')
        }
        
        # æ£€æŸ¥å…³é”®æ–‡ä»¶å†…å®¹
        if status['wsgi_exists']:
            try:
                with open('wsgi.py', 'r', encoding='utf-8') as f:
                    content = f.read()
                    status['wsgi_imports_app'] = 'from app import app' in content
            except:
                status['wsgi_imports_app'] = False
        
        # ä¿å­˜çŠ¶æ€åˆ°æ–‡ä»¶
        with open(self.status_file, 'w', encoding='utf-8') as f:
            json.dump(status, f, ensure_ascii=False, indent=2)
        
        return status
    
    def start_monitoring(self, interval=5):
        """å¼€å§‹ç›‘è§†"""
        print("ğŸš€ Claude Code ç›‘è§†å™¨å¯åŠ¨")
        print(f"ğŸ“ ç›‘è§†ç›®å½•: {self.project_path.absolute()}")
        print(f"â±ï¸  æ£€æŸ¥é—´éš”: {interval}ç§’")
        print("=" * 50)
        
        # åˆå§‹æ‰«æ
        self.file_hashes = self.scan_files()
        self.log_event("INIT", f"å¼€å§‹ç›‘è§†ï¼Œå‘ç° {len(self.file_hashes)} ä¸ªæ–‡ä»¶")
        
        try:
            while True:
                # æ£€æµ‹æ–‡ä»¶å˜æ›´
                changes = self.detect_changes()
                
                if any(changes.values()):
                    self.log_event("CHANGE", "æ£€æµ‹åˆ°æ–‡ä»¶å˜æ›´", changes)
                
                # æ£€æŸ¥åº”ç”¨çŠ¶æ€
                status = self.check_application_status()
                
                time.sleep(interval)
                
        except KeyboardInterrupt:
            self.log_event("STOP", "ç›‘è§†å™¨å·²åœæ­¢")
            print("\nğŸ‘‹ ç›‘è§†å™¨å·²åœæ­¢")

def main():
    """ä¸»å‡½æ•°"""
    monitor = ClaudeCodeMonitor()
    
    # æ£€æŸ¥å½“å‰çŠ¶æ€
    print("ğŸ“Š å½“å‰é¡¹ç›®çŠ¶æ€:")
    status = monitor.check_application_status()
    for key, value in status.items():
        if key != 'timestamp':
            status_icon = "âœ…" if value else "âŒ"
            print(f"  {status_icon} {key}: {value}")
    
    print("\n" + "=" * 50)
    
    # å¼€å§‹ç›‘è§†
    try:
        monitor.start_monitoring(interval=3)
    except Exception as e:
        print(f"âŒ ç›‘è§†å™¨é”™è¯¯: {e}")

if __name__ == '__main__':
    main()
